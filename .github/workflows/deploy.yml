name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          envs: DB_USER,DB_PASS,DB_NAME,BX24_OUTGOING_TOKEN,BX24_INCOMING_TOKEN,BX24_INCOMING_USER,BX24_DOMAIN,TELEGRAM_BOT_TOKEN,APP_DIR
          script_stop: true
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          BX24_OUTGOING_TOKEN: ${{ secrets.BX24_OUTGOING_TOKEN }}
          BX24_INCOMING_TOKEN: ${{ secrets.BX24_INCOMING_TOKEN }}
          BX24_INCOMING_USER: ${{ secrets.BX24_INCOMING_USER }}
          BX24_DOMAIN: ${{ secrets.BX24_DOMAIN }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          APP_DIR: ${{ secrets.APP_DIR }}
        script: |
            set -e
            APP_DIR="${APP_DIR:-/root/bx-tg-notify}"
            cd "$APP_DIR"
            
            # Сохраняем текущую версию для отката
            CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "none")
            echo "CURRENT_COMMIT=$CURRENT_COMMIT" > /tmp/rollback_info
            
            # Получаем последние изменения
            git fetch origin
            git reset --hard origin/main
            
            # Создаем .env файл из секретов
            cat > .production.env << EOF
          NODE_ENV=production
          
          DB_HOST=mysql
          DB_PORT=3306
          DB_USER=${DB_USER}
          DB_PASS=${DB_PASS}
          DB_NAME=${DB_NAME}
          
          BX24_OUTGOING_TOKEN=${BX24_OUTGOING_TOKEN}
          BX24_INCOMING_TOKEN=${BX24_INCOMING_TOKEN}
          BX24_INCOMING_USER=${BX24_INCOMING_USER}
          BX24_DOMAIN=${BX24_DOMAIN}
          
          TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
          
          APP_PORT=3000
          EOF
            
            # Останавливаем контейнеры
            docker compose --profile production down || true
            
            # Собираем и запускаем
            ENV_FILE=.production.env docker compose --profile production up -d --build
            
            # Ждем готовности
            echo "Waiting for services to be healthy..."
            sleep 15
            
            # Проверяем здоровье контейнеров
            if ! docker compose --profile production ps | grep -q "healthy"; then
              echo "Health check failed, rolling back..."
              
              # Откат к предыдущей версии
              if [ "$CURRENT_COMMIT" != "none" ]; then
                git reset --hard $CURRENT_COMMIT
                ENV_FILE=.production.env docker compose --profile production up -d --build
              else
                docker compose --profile production down
              fi
              
              exit 1
            fi
            
            # Проверяем что приложение отвечает
            sleep 5
            if ! curl -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "Application health check failed, rolling back..."
              
              if [ "$CURRENT_COMMIT" != "none" ]; then
                git reset --hard $CURRENT_COMMIT
                ENV_FILE=.production.env docker compose --profile production up -d --build
              else
                docker compose --profile production down
              fi
              
              exit 1
            fi
            
            echo "Deployment successful!"

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check logs on server."
