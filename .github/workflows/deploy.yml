name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: 864
          envs: DB_USER,DB_PASS,DB_NAME,BX24_OUTGOING_TOKEN,BX24_INCOMING_TOKEN,BX24_INCOMING_USER,BX24_DOMAIN,TELEGRAM_BOT_TOKEN,APP_DIR,APP_URL
          script_stop: true
          script: |
            set -e
            APP_DIR="${APP_DIR:-/root/bx-tg-notify}"
            cd "$APP_DIR"
            
            # Сохраняем текущую версию для отката
            CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "none")
            echo "CURRENT_COMMIT=$CURRENT_COMMIT" > /tmp/rollback_info
            
            # Получаем последние изменения
            # Переключаемся на HTTPS если используется SSH URL
            git remote set-url origin https://github.com/temakulakov/bx-tg-notify.git || true
            git fetch origin
            git reset --hard origin/main
            
            # Создаем .env файл из секретов
            # Используем printf для безопасной обработки специальных символов
            # Экранируем значения, которые могут содержать специальные символы
            {
              echo "NODE_ENV=production"
              echo ""
              echo "DB_HOST=mysql"
              echo "DB_PORT=3306"
              echo "DB_USER=${DB_USER}"
              # Экранируем пароль: заменяем $ на $$ для docker-compose и экранируем кавычки
              DB_PASS_ESCAPED=$(printf '%s' "${DB_PASS}" | sed 's/\$/$$/g')
              echo "DB_PASS=${DB_PASS_ESCAPED}"
              echo "DB_NAME=${DB_NAME}"
              echo ""
              echo "BX24_OUTGOING_TOKEN=${BX24_OUTGOING_TOKEN}"
              echo "BX24_INCOMING_TOKEN=${BX24_INCOMING_TOKEN}"
              echo "BX24_INCOMING_USER=${BX24_INCOMING_USER}"
              echo "BX24_DOMAIN=${BX24_DOMAIN}"
              echo ""
            echo "TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}"
            echo ""
            echo "APP_PORT=3000"
            # Убираем trailing slash из APP_URL если есть
            APP_URL_CLEANED=$(echo "${APP_URL:-https://shebo.h512.ru}" | sed 's/\/$//')
            echo "APP_URL=${APP_URL_CLEANED}"
            } > .production.env
            
            # Проверяем что файл создан (без показа паролей)
            echo "=== DEBUG: Checking .production.env file ==="
            if [ -f .production.env ]; then
              echo "File exists."
              echo "DB_USER=$(grep '^DB_USER=' .production.env | cut -d'=' -f2)"
              echo "DB_NAME=$(grep '^DB_NAME=' .production.env | cut -d'=' -f2)"
              echo "DB_HOST=$(grep '^DB_HOST=' .production.env | cut -d'=' -f2)"
              echo "DB_PORT=$(grep '^DB_PORT=' .production.env | cut -d'=' -f2)"
              DB_PASS_LENGTH=$(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | wc -c)
              echo "DB_PASS length: $((DB_PASS_LENGTH - 1)) characters"
              echo "DB_PASS first char: $(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | cut -c1)"
              echo "DB_PASS last char: $(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | rev | cut -c1)"
            else
              echo "ERROR: .production.env file not created!"
              exit 1
            fi
            
            # Выводим данные из secrets (ПОЛНЫЙ ВЫВОД ДЛЯ ОТЛАДКИ)
            echo ""
            echo "=== DEBUG: Secrets data (from environment) - FULL OUTPUT ==="
            echo "DB_USER=${DB_USER}"
            echo "DB_NAME=${DB_NAME}"
            echo "DB_HOST=${DB_HOST:-not set}"
            echo "DB_PASS=${DB_PASS}"
            echo "DB_PASS length: ${#DB_PASS} characters"
            
            # Останавливаем контейнеры и удаляем volumes для пересоздания MySQL с новыми учетными данными
            echo "Stopping containers and removing MySQL volume..."
            docker compose --profile production down -v || true
            
            # Ждем немного перед пересозданием
            sleep 2
            
            # Собираем и запускаем
            ENV_FILE=.production.env docker compose --profile production up -d --build
            
            # Ждем готовности MySQL
            echo "Waiting for MySQL to be healthy..."
            for i in {1..30}; do
              if docker compose --profile production ps mysql | grep -q "healthy"; then
                echo "MySQL is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: MySQL did not become healthy in time"
                docker compose --profile production logs mysql | tail -50
                exit 1
              fi
              echo "Waiting for MySQL... ($i/30)"
              sleep 2
            done
            
            # Дополнительно ждем, чтобы MySQL полностью инициализировался
            echo "Waiting for MySQL to be fully ready..."
            sleep 10
            
            # Исправляем права пользователя MySQL для доступа из Docker сети
            echo ""
            echo "=== DEBUG: Configuring MySQL user permissions ==="
            echo "Using DB_USER: ${DB_USER}"
            echo "Using DB_NAME: ${DB_NAME}"
            echo "Using DB_PASS length: ${#DB_PASS} characters"
            
            # Экранируем значения для SQL запросов
            DB_PASS_ESCAPED=$(echo "${DB_PASS}" | sed "s/'/''/g")
            DB_USER_ESCAPED=$(echo "${DB_USER}" | sed "s/'/''/g")
            DB_NAME_ESCAPED=$(echo "${DB_NAME}" | sed "s/'/''/g")
            
            # Используем root пароль (который равен DB_PASS в docker-compose) для настройки пользователя
            # MySQL создается через docker-compose с MYSQL_ROOT_PASSWORD=${DB_PASS}
            export MYSQL_PWD="${DB_PASS}"
            
            # Проверяем какие пользователи уже существуют
            echo ""
            echo "=== DEBUG: Checking existing MySQL users ==="
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -uroot -e "SELECT User, Host, authentication_string IS NOT NULL as has_password FROM mysql.user WHERE User='${DB_USER}';" 2>&1 || echo "Warning: Could not query MySQL users"
            
            # Удаляем пользователя если он существует и создаем заново с доступом с любого хоста
            echo ""
            echo "=== DEBUG: Dropping and recreating MySQL user ==="
            # Создаем базу данных, если она не существует
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -uroot -e "CREATE DATABASE IF NOT EXISTS \`${DB_NAME_ESCAPED}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>&1 || echo "Warning: Could not create database"
            # Удаляем и создаем пользователя заново
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -uroot -e "DROP USER IF EXISTS '${DB_USER_ESCAPED}'@'localhost'; DROP USER IF EXISTS '${DB_USER_ESCAPED}'@'%'; CREATE USER '${DB_USER_ESCAPED}'@'%' IDENTIFIED BY '${DB_PASS_ESCAPED}'; GRANT ALL PRIVILEGES ON \`${DB_NAME_ESCAPED}\`.* TO '${DB_USER_ESCAPED}'@'%'; FLUSH PRIVILEGES;" 2>&1 || echo "Warning: Could not configure MySQL user"
            
            # Проверяем что пользователь создан правильно - ПОЛНАЯ ИНФОРМАЦИЯ
            echo ""
            echo "=== DEBUG: Verifying MySQL user after creation - FULL INFO ==="
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -uroot -e "SELECT User, Host, plugin, LEFT(authentication_string, 20) as auth_string_start, LENGTH(authentication_string) as auth_string_length FROM mysql.user WHERE User='${DB_USER}';" 2>&1 || echo "Warning: Could not verify MySQL user"
            
            # Проверяем что пользователь может подключиться к базе данных
            echo ""
            echo "=== DEBUG: Testing MySQL user connection ==="
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" -e "SELECT 'Connection successful' as status, USER() as \`current_user\`, DATABASE() as \`current_database\`;" 2>&1 || echo "Warning: Could not test MySQL user connection"
            
            # Выполняем миграции базы данных
            echo ""
            echo "=== Running database migrations ==="
            if [ -f migrations/create-all-tables.sql ]; then
              echo "Running create-all-tables.sql migration..."
              cat migrations/create-all-tables.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" 2>&1 || echo "Warning: Migration failed (may already be applied)"
            fi
            # Также выполняем существующие миграции для обратной совместимости
            if [ -f migrations/add-webapp-tables.sql ]; then
              echo "Running add-webapp-tables.sql migration..."
              cat migrations/add-webapp-tables.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" 2>&1 || echo "Warning: Migration failed (may already be applied)"
            fi
            if [ -f migrations/add-replicate-column.sql ]; then
              echo "Running add-replicate-column.sql migration..."
              cat migrations/add-replicate-column.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" 2>&1 || echo "Warning: Migration failed (may already be applied)"
            fi
            echo "Migrations completed!"
            
            # Загружаем данные из SQL файлов, если они существуют
            echo ""
            echo "=== Loading data from SQL files ==="
            # Используем DB_NAME вместо hardcoded 'shebo' в SQL файлах и INSERT IGNORE для безопасной повторной загрузки
            # Используем --default-character-set=utf8mb4 для правильной обработки кириллицы
            if [ -f migrations/phrases.sql ]; then
              echo "Loading phrases.sql..."
              sed "s/INSERT INTO shebo\./INSERT IGNORE INTO ${DB_NAME}./g" migrations/phrases.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql --default-character-set=utf8mb4 -u"${DB_USER}" "${DB_NAME}" 2>&1 | grep -v "^$" || echo "Warning: Could not load phrases.sql (may already be loaded)"
            fi
            if [ -f migrations/tasks.sql ]; then
              echo "Loading tasks.sql (this may take a while)..."
              sed "s/INSERT INTO shebo\./INSERT IGNORE INTO ${DB_NAME}./g" migrations/tasks.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql --default-character-set=utf8mb4 -u"${DB_USER}" "${DB_NAME}" 2>&1 | head -20 || echo "Warning: Could not load tasks.sql (may already be loaded)"
            fi
            if [ -f migrations/users_shebo.sql ]; then
              echo "Loading users_shebo.sql..."
              sed "s/INSERT INTO shebo\./INSERT IGNORE INTO ${DB_NAME}./g" migrations/users_shebo.sql | ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql --default-character-set=utf8mb4 -u"${DB_USER}" "${DB_NAME}" 2>&1 | grep -v "^$" || echo "Warning: Could not load users_shebo.sql (may already be loaded)"
            fi
            echo "Data loading completed!"
            
            # Проверяем что таблицы созданы
            echo ""
            echo "=== Verifying tables were created ==="
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" -e "SHOW TABLES;" 2>&1 || echo "Warning: Could not list tables"
            ENV_FILE=.production.env docker compose --profile production exec -T -e MYSQL_PWD="${DB_PASS}" mysql mysql -u"${DB_USER}" "${DB_NAME}" -e "SELECT COUNT(*) as phrases_count FROM phrases;" 2>&1 || echo "Warning: Could not query phrases table"
            
            # Перезапускаем приложение после миграций, чтобы оно подключилось к обновленной базе
            echo ""
            echo "=== Restarting application after migrations ==="
            ENV_FILE=.production.env docker compose --profile production restart app
            echo "Application restarted, waiting for it to start..."
            sleep 15
            
            # Проверяем переменные окружения в контейнере приложения
            echo "Checking environment variables in app container..."
            ENV_FILE=.production.env docker compose --profile production exec -T app env | grep -E "DB_|NODE_ENV|APP_URL" || echo "Warning: Could not check env vars"
            
            # Проверяем что приложение отвечает
            echo "Checking application health endpoint..."
            for i in {1..30}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "Application is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Application health check failed after 60 seconds"
                echo ""
                echo "=== Application logs ==="
                docker compose --profile production logs app | tail -100
                echo ""
                echo "=== MySQL logs ==="
                docker compose --profile production logs mysql | tail -50
                echo ""
                echo "=== Checking .production.env file ==="
                cat .production.env | grep -v "PASS\|TOKEN" || echo "File not readable"
                echo ""
                echo "=== Checking if app container has env vars ==="
                ENV_FILE=.production.env docker compose --profile production exec -T app env | grep -E "DB_|NODE_ENV" || echo "Cannot exec into container"
                echo ""
                echo "=== Rolling back ==="
                
                # Откат к предыдущей версии
                if [ "$CURRENT_COMMIT" != "none" ]; then
                  git reset --hard $CURRENT_COMMIT
                  ENV_FILE=.production.env docker compose --profile production up -d --build
                else
                  docker compose --profile production down
                fi
                
                exit 1
              fi
              echo "Waiting for application health... ($i/30)"
              # Показываем последние логи приложения для отладки
              if [ $((i % 5)) -eq 0 ]; then
                echo "Recent app logs:"
                docker compose --profile production logs app --tail=10 2>&1 | tail -5
              fi
              sleep 2
            done
            
            echo "Deployment successful!"
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          BX24_OUTGOING_TOKEN: ${{ secrets.BX24_OUTGOING_TOKEN }}
          BX24_INCOMING_TOKEN: ${{ secrets.BX24_INCOMING_TOKEN }}
          BX24_INCOMING_USER: ${{ secrets.BX24_INCOMING_USER }}
          BX24_DOMAIN: ${{ secrets.BX24_DOMAIN }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          APP_DIR: ${{ secrets.APP_DIR }}
          APP_URL: ${{ secrets.APP_URL }}

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check logs on server."
