name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: 22
          envs: DB_USER,DB_PASS,DB_NAME,BX24_OUTGOING_TOKEN,BX24_INCOMING_TOKEN,BX24_INCOMING_USER,BX24_DOMAIN,TELEGRAM_BOT_TOKEN,APP_DIR
          script_stop: true
          script: |
            set -e
            APP_DIR="${APP_DIR:-/root/bx-tg-notify}"
            cd "$APP_DIR"
            
            # Сохраняем текущую версию для отката
            CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "none")
            echo "CURRENT_COMMIT=$CURRENT_COMMIT" > /tmp/rollback_info
            
            # Получаем последние изменения
            # Переключаемся на HTTPS если используется SSH URL
            git remote set-url origin https://github.com/temakulakov/bx-tg-notify.git || true
            git fetch origin
            git reset --hard origin/main
            
            # Создаем .env файл из секретов
            # Используем printf для безопасной обработки специальных символов
            printf 'NODE_ENV=production\n\n' > .production.env
            printf 'DB_HOST=mysql\n' >> .production.env
            printf 'DB_PORT=3306\n' >> .production.env
            printf 'DB_USER=%s\n' "${DB_USER}" >> .production.env
            printf 'DB_PASS=%s\n' "${DB_PASS}" >> .production.env
            printf 'DB_NAME=%s\n' "${DB_NAME}" >> .production.env
            printf '\n' >> .production.env
            printf 'BX24_OUTGOING_TOKEN=%s\n' "${BX24_OUTGOING_TOKEN}" >> .production.env
            printf 'BX24_INCOMING_TOKEN=%s\n' "${BX24_INCOMING_TOKEN}" >> .production.env
            printf 'BX24_INCOMING_USER=%s\n' "${BX24_INCOMING_USER}" >> .production.env
            printf 'BX24_DOMAIN=%s\n' "${BX24_DOMAIN}" >> .production.env
            printf '\n' >> .production.env
            printf 'TELEGRAM_BOT_TOKEN=%s\n' "${TELEGRAM_BOT_TOKEN}" >> .production.env
            printf '\n' >> .production.env
            printf 'APP_PORT=3000\n' >> .production.env
            
            # Проверяем что файл создан (без показа паролей)
            echo "=== DEBUG: Checking .production.env file ==="
            if [ -f .production.env ]; then
              echo "File exists."
              echo "DB_USER=$(grep '^DB_USER=' .production.env | cut -d'=' -f2)"
              echo "DB_NAME=$(grep '^DB_NAME=' .production.env | cut -d'=' -f2)"
              echo "DB_HOST=$(grep '^DB_HOST=' .production.env | cut -d'=' -f2)"
              echo "DB_PORT=$(grep '^DB_PORT=' .production.env | cut -d'=' -f2)"
              DB_PASS_LENGTH=$(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | wc -c)
              echo "DB_PASS length: $((DB_PASS_LENGTH - 1)) characters"
              echo "DB_PASS first char: $(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | cut -c1)"
              echo "DB_PASS last char: $(grep '^DB_PASS=' .production.env | cut -d'=' -f2 | rev | cut -c1)"
            else
              echo "ERROR: .production.env file not created!"
              exit 1
            fi
            
            # Выводим данные из secrets (безопасно)
            echo ""
            echo "=== DEBUG: Secrets data (from environment) ==="
            echo "DB_USER=${DB_USER}"
            echo "DB_NAME=${DB_NAME}"
            echo "DB_HOST=${DB_HOST:-not set}"
            echo "DB_PASS length: ${#DB_PASS} characters"
            echo "DB_PASS first char: ${DB_PASS:0:1}"
            echo "DB_PASS last char: ${DB_PASS: -1}"
            
            # Останавливаем контейнеры и удаляем volumes для пересоздания MySQL с новыми учетными данными
            echo "Stopping containers and removing MySQL volume..."
            docker compose --profile production down -v || true
            
            # Ждем немного перед пересозданием
            sleep 2
            
            # Собираем и запускаем
            ENV_FILE=.production.env docker compose --profile production up -d --build
            
            # Ждем готовности MySQL
            echo "Waiting for MySQL to be healthy..."
            for i in {1..30}; do
              if docker compose --profile production ps mysql | grep -q "healthy"; then
                echo "MySQL is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: MySQL did not become healthy in time"
                docker compose --profile production logs mysql | tail -50
                exit 1
              fi
              echo "Waiting for MySQL... ($i/30)"
              sleep 2
            done
            
            # Исправляем права пользователя MySQL для доступа из Docker сети
            echo ""
            echo "=== DEBUG: Configuring MySQL user permissions ==="
            echo "Using DB_USER: ${DB_USER}"
            echo "Using DB_NAME: ${DB_NAME}"
            echo "Using DB_PASS length: ${#DB_PASS} characters"
            sleep 5
            
            # Проверяем какие пользователи уже существуют
            echo ""
            echo "=== DEBUG: Checking existing MySQL users ==="
            ENV_FILE=.production.env docker compose --profile production exec -T mysql mysql -uroot -p"${DB_PASS}" -e "SELECT User, Host, authentication_string IS NOT NULL as has_password FROM mysql.user WHERE User='${DB_USER}';" 2>&1 || echo "Warning: Could not query MySQL users"
            
            # Удаляем пользователя если он существует и создаем заново с доступом с любого хоста
            echo ""
            echo "=== DEBUG: Dropping and recreating MySQL user ==="
            ENV_FILE=.production.env docker compose --profile production exec -T mysql mysql -uroot -p"${DB_PASS}" -e "DROP USER IF EXISTS '${DB_USER}'@'localhost'; DROP USER IF EXISTS '${DB_USER}'@'%'; CREATE USER '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASS}'; GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'%'; FLUSH PRIVILEGES;" 2>&1 || echo "Warning: Could not configure MySQL user"
            
            # Проверяем что пользователь создан правильно
            echo ""
            echo "=== DEBUG: Verifying MySQL user after creation ==="
            ENV_FILE=.production.env docker compose --profile production exec -T mysql mysql -uroot -p"${DB_PASS}" -e "SELECT User, Host, plugin, authentication_string IS NOT NULL as has_password FROM mysql.user WHERE User='${DB_USER}';" 2>&1 || echo "Warning: Could not verify MySQL user"
            
            # Проверяем что пользователь может подключиться
            echo ""
            echo "=== DEBUG: Testing MySQL user connection ==="
            ENV_FILE=.production.env docker compose --profile production exec -T mysql mysql -u"${DB_USER}" -p"${DB_PASS}" -e "SELECT 'Connection successful' as status, USER() as current_user, DATABASE() as current_database;" 2>&1 || echo "Warning: Could not test MySQL user connection"
            
            # Ждем запуска приложения
            echo "Waiting for application to start..."
            sleep 20
            
            # Проверяем переменные окружения в контейнере приложения
            echo "Checking environment variables in app container..."
            ENV_FILE=.production.env docker compose --profile production exec -T app env | grep -E "DB_|NODE_ENV" || echo "Warning: Could not check env vars"
            
            # Проверяем что приложение отвечает
            echo "Checking application health endpoint..."
            for i in {1..30}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "Application is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Application health check failed after 60 seconds"
                echo ""
                echo "=== Application logs ==="
                docker compose --profile production logs app | tail -100
                echo ""
                echo "=== MySQL logs ==="
                docker compose --profile production logs mysql | tail -50
                echo ""
                echo "=== Checking .production.env file ==="
                cat .production.env | grep -v "PASS\|TOKEN" || echo "File not readable"
                echo ""
                echo "=== Checking if app container has env vars ==="
                ENV_FILE=.production.env docker compose --profile production exec -T app env | grep -E "DB_|NODE_ENV" || echo "Cannot exec into container"
                echo ""
                echo "=== Rolling back ==="
                
                # Откат к предыдущей версии
                if [ "$CURRENT_COMMIT" != "none" ]; then
                  git reset --hard $CURRENT_COMMIT
                  ENV_FILE=.production.env docker compose --profile production up -d --build
                else
                  docker compose --profile production down
                fi
                
                exit 1
              fi
              echo "Waiting for application health... ($i/30)"
              # Показываем последние логи приложения для отладки
              if [ $((i % 5)) -eq 0 ]; then
                echo "Recent app logs:"
                docker compose --profile production logs app --tail=10 2>&1 | tail -5
              fi
              sleep 2
            done
            
            echo "Deployment successful!"
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          BX24_OUTGOING_TOKEN: ${{ secrets.BX24_OUTGOING_TOKEN }}
          BX24_INCOMING_TOKEN: ${{ secrets.BX24_INCOMING_TOKEN }}
          BX24_INCOMING_USER: ${{ secrets.BX24_INCOMING_USER }}
          BX24_DOMAIN: ${{ secrets.BX24_DOMAIN }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          APP_DIR: ${{ secrets.APP_DIR }}

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check logs on server."
